{"ast":null,"code":"import { cartesian, cartesianAddInPlace, cartesianCross, cartesianDot, cartesianScale, spherical } from \"../cartesian.js\";\nimport { circleStream } from \"../circle.js\";\nimport { abs, cos, epsilon, pi, radians, sqrt } from \"../math.js\";\nimport pointEqual from \"../pointEqual.js\";\nimport clip from \"./index.js\";\nexport default function (radius) {\n  var cr = cos(radius),\n      delta = 6 * radians,\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos(lambda) * cos(phi) > cr;\n  } // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n\n\n  function clipLine(stream) {\n    var point0, // previous point\n    c0, // code for previous point\n    v0, // visibility of previous point\n    v00, // visibility of first point\n    clean; // no intersections\n\n    return {\n      lineStart: function () {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function (lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) point1[2] = 1;\n        }\n\n        if (v !== v0) {\n          clean = 0;\n\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1], 2);\n            stream.lineEnd();\n          }\n\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t; // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1], 3);\n            }\n          }\n        }\n\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function () {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function () {\n        return clean | (v00 && v0) << 1;\n      }\n    };\n  } // Intersects the great circle between a and b with the clip circle.\n\n\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b); // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 тип n2).\n\n    var n1 = [1, 0, 0],\n        // normal\n    n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0],\n        // cartesianDot(n1, n2),\n    determinant = n2n2 - n1n2 * n1n2; // Two polar points.\n\n    if (!determinant) return !two && a;\n    var c1 = cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B); // Solve |p(t)|^2 = 1.\n\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n    if (t2 < 0) return;\n    var t = sqrt(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n    if (!two) return q; // Two intersection points.\n\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi) < epsilon,\n        meridian = polar || delta < epsilon;\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z; // Check that the first point is between a and b.\n\n    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  } // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n\n\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n}","map":{"version":3,"names":["cartesian","cartesianAddInPlace","cartesianCross","cartesianDot","cartesianScale","spherical","circleStream","abs","cos","epsilon","pi","radians","sqrt","pointEqual","clip","radius","cr","delta","smallRadius","notHemisphere","interpolate","from","to","direction","stream","visible","lambda","phi","clipLine","point0","c0","v0","v00","clean","lineStart","point","point1","point2","v","c","code","intersect","lineEnd","t","a","b","two","pa","pb","n1","n2","n2n2","n1n2","determinant","c1","c2","n1xn2","A","B","u","w","uu","t2","q","lambda0","lambda1","phi0","phi1","z","polar","meridian","q1","r"],"sources":["/home/aurimas/coding/idendro/frontend/node_modules/d3-geo/src/clip/circle.js"],"sourcesContent":["import {cartesian, cartesianAddInPlace, cartesianCross, cartesianDot, cartesianScale, spherical} from \"../cartesian.js\";\nimport {circleStream} from \"../circle.js\";\nimport {abs, cos, epsilon, pi, radians, sqrt} from \"../math.js\";\nimport pointEqual from \"../pointEqual.js\";\nimport clip from \"./index.js\";\n\nexport default function(radius) {\n  var cr = cos(radius),\n      delta = 6 * radians,\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos(lambda) * cos(phi) > cr;\n  }\n\n  // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n  function clipLine(stream) {\n    var point0, // previous point\n        c0, // code for previous point\n        v0, // visibility of previous point\n        v00, // visibility of first point\n        clean; // no intersections\n    return {\n      lineStart: function() {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function(lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius\n              ? v ? 0 : code(lambda, phi)\n              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))\n            point1[2] = 1;\n        }\n        if (v !== v0) {\n          clean = 0;\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1], 2);\n            stream.lineEnd();\n          }\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t;\n          // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1], 3);\n            }\n          }\n        }\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function() {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return clean | ((v00 && v0) << 1);\n      }\n    };\n  }\n\n  // Intersects the great circle between a and b with the clip circle.\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b);\n\n    // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 тип n2).\n    var n1 = [1, 0, 0], // normal\n        n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0], // cartesianDot(n1, n2),\n        determinant = n2n2 - n1n2 * n1n2;\n\n    // Two polar points.\n    if (!determinant) return !two && a;\n\n    var c1 =  cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B);\n\n    // Solve |p(t)|^2 = 1.\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\n    if (t2 < 0) return;\n\n    var t = sqrt(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n\n    if (!two) return q;\n\n    // Two intersection points.\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi) < epsilon,\n        meridian = polar || delta < epsilon;\n\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n    // Check that the first point is between a and b.\n    if (meridian\n        ? polar\n          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n          : phi0 <= q[1] && q[1] <= phi1\n        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  }\n\n  // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}