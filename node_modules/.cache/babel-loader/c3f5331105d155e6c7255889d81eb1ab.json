{"ast":null,"code":"import { Selection } from \"./index.js\";\nimport { EnterNode } from \"./enter.js\";\nimport constant from \"../constant.js\";\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length; // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  } // Put any non-null nodes that don’t fit into exit.\n\n\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = new Map(),\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue; // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + \"\";\n\n      if (nodeByKeyValue.has(keyValue)) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue.set(keyValue, node);\n      }\n    }\n  } // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n\n\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = key.call(parent, data[i], i, data) + \"\";\n\n    if (node = nodeByKeyValue.get(keyValue)) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue.delete(keyValue);\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  } // Add any remaining nodes that were not bound to data to exit.\n\n\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction datum(node) {\n  return node.__data__;\n}\n\nexport default function (value, key) {\n  if (!arguments.length) return Array.from(this, datum);\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n  if (typeof value !== \"function\") value = constant(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key); // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength) {\n          ;\n        }\n\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n} // Given some data, this returns an array-like view of it: an object that\n// exposes a length property and allows numeric indexing. Note that unlike\n// selectAll, this isn’t worried about “live” collections because the resulting\n// array will only be used briefly while data is being bound. (It is possible to\n// cause the data to change while iterating by using a key function, but please\n// don’t; we’d rather avoid a gratuitous copy.)\n\nfunction arraylike(data) {\n  return typeof data === \"object\" && \"length\" in data ? data // Array, TypedArray, NodeList, array-like\n  : Array.from(data); // Map, Set, iterable, string, or anything else\n}","map":{"version":3,"names":["Selection","EnterNode","constant","bindIndex","parent","group","enter","update","exit","data","i","node","groupLength","length","dataLength","__data__","bindKey","key","nodeByKeyValue","Map","keyValues","Array","keyValue","call","has","set","get","delete","datum","value","arguments","from","bind","parents","_parents","groups","_groups","m","j","arraylike","enterGroup","updateGroup","exitGroup","i0","i1","previous","next","_next","_enter","_exit"],"sources":["/home/aurimas/coding/idendro/frontend/node_modules/d3-selection/src/selection/data.js"],"sourcesContent":["import {Selection} from \"./index.js\";\nimport {EnterNode} from \"./enter.js\";\nimport constant from \"../constant.js\";\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length;\n\n  // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Put any non-null nodes that don’t fit into exit.\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = new Map,\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue;\n\n  // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + \"\";\n      if (nodeByKeyValue.has(keyValue)) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue.set(keyValue, node);\n      }\n    }\n  }\n\n  // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = key.call(parent, data[i], i, data) + \"\";\n    if (node = nodeByKeyValue.get(keyValue)) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue.delete(keyValue);\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Add any remaining nodes that were not bound to data to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction datum(node) {\n  return node.__data__;\n}\n\nexport default function(value, key) {\n  if (!arguments.length) return Array.from(this, datum);\n\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n\n  if (typeof value !== \"function\") value = constant(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n\n    // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}\n\n// Given some data, this returns an array-like view of it: an object that\n// exposes a length property and allows numeric indexing. Note that unlike\n// selectAll, this isn’t worried about “live” collections because the resulting\n// array will only be used briefly while data is being bound. (It is possible to\n// cause the data to change while iterating by using a key function, but please\n// don’t; we’d rather avoid a gratuitous copy.)\nfunction arraylike(data) {\n  return typeof data === \"object\" && \"length\" in data\n    ? data // Array, TypedArray, NodeList, array-like\n    : Array.from(data); // Map, Set, iterable, string, or anything else\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}