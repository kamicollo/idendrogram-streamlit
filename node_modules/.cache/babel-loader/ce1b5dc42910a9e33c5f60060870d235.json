{"ast":null,"code":"import clipBuffer from \"./buffer.js\";\nimport clipRejoin from \"./rejoin.js\";\nimport { epsilon, halfPi } from \"../math.js\";\nimport polygonContains from \"../polygonContains.js\";\nimport { merge } from \"d3-array\";\nexport default function (pointVisible, clipLine, interpolate, start) {\n  return function (sink) {\n    var line = clipLine(sink),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function () {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function () {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, start);\n\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function () {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      if (pointVisible(lambda, phi)) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      line.point(lambda, phi);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      ringSink.point(lambda, phi);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i,\n          n = ringSegments.length,\n          m,\n          segment,\n          point;\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n      if (!n) return; // No intersections.\n\n      if (clean & 1) {\n        segment = ringSegments[0];\n\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n\n          sink.lineEnd();\n        }\n\n        return;\n      } // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n\n\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n}\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n} // Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\n\n\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}","map":{"version":3,"names":["clipBuffer","clipRejoin","epsilon","halfPi","polygonContains","merge","pointVisible","clipLine","interpolate","start","sink","line","ringBuffer","ringSink","polygonStarted","polygon","segments","ring","clip","point","lineStart","lineEnd","polygonStart","pointRing","ringStart","ringEnd","polygonEnd","startInside","length","compareIntersection","sphere","lambda","phi","pointLine","push","clean","ringSegments","result","i","n","m","segment","pop","concat","shift","filter","validSegment","a","b","x"],"sources":["/home/aurimas/coding/idendro/idendro/targets/streamlit-frontend/node_modules/d3-geo/src/clip/index.js"],"sourcesContent":["import clipBuffer from \"./buffer.js\";\nimport clipRejoin from \"./rejoin.js\";\nimport {epsilon, halfPi} from \"../math.js\";\nimport polygonContains from \"../polygonContains.js\";\nimport {merge} from \"d3-array\";\n\nexport default function(pointVisible, clipLine, interpolate, start) {\n  return function(sink) {\n    var line = clipLine(sink),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, start);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      if (pointVisible(lambda, phi)) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      line.point(lambda, phi);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      ringSink.point(lambda, phi);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i, n = ringSegments.length, m,\n          segment,\n          point;\n\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n}\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}