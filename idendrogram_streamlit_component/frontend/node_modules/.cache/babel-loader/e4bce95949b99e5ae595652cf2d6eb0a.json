{"ast":null,"code":"import { optional } from \"./accessors.js\";\nimport { Node, computeHeight } from \"./hierarchy/index.js\";\nvar preroot = {\n  depth: -1\n},\n    ambiguous = {},\n    imputed = {};\n\nfunction defaultId(d) {\n  return d.id;\n}\n\nfunction defaultParentId(d) {\n  return d.parentId;\n}\n\nexport default function () {\n  var id = defaultId,\n      parentId = defaultParentId,\n      path;\n\n  function stratify(data) {\n    var nodes = Array.from(data),\n        currentId = id,\n        currentParentId = parentId,\n        n,\n        d,\n        i,\n        root,\n        parent,\n        node,\n        nodeId,\n        nodeKey,\n        nodeByKey = new Map();\n\n    if (path != null) {\n      const I = nodes.map((d, i) => normalize(path(d, i, data)));\n      const P = I.map(parentof);\n      const S = new Set(I).add(\"\");\n\n      for (const i of P) {\n        if (!S.has(i)) {\n          S.add(i);\n          I.push(i);\n          P.push(parentof(i));\n          nodes.push(imputed);\n        }\n      }\n\n      currentId = (_, i) => I[i];\n\n      currentParentId = (_, i) => P[i];\n    }\n\n    for (i = 0, n = nodes.length; i < n; ++i) {\n      d = nodes[i], node = nodes[i] = new Node(d);\n\n      if ((nodeId = currentId(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = node.id = nodeId;\n        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);\n      }\n\n      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += \"\")) {\n        node.parent = nodeId;\n      }\n    }\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n\n      if (nodeId = node.parent) {\n        parent = nodeByKey.get(nodeId);\n        if (!parent) throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous) throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children) parent.children.push(node);else parent.children = [node];\n        node.parent = parent;\n      } else {\n        if (root) throw new Error(\"multiple roots\");\n        root = node;\n      }\n    }\n\n    if (!root) throw new Error(\"no root\"); // When imputing internal nodes, only introduce roots if needed.\n    // Then replace the imputed marker data with null.\n\n    if (path != null) {\n      while (root.data === imputed && root.children.length === 1) {\n        root = root.children[0], --n;\n      }\n\n      for (let i = nodes.length - 1; i >= 0; --i) {\n        node = nodes[i];\n        if (node.data !== imputed) break;\n        node.data = null;\n      }\n    }\n\n    root.parent = preroot;\n    root.eachBefore(function (node) {\n      node.depth = node.parent.depth + 1;\n      --n;\n    }).eachBefore(computeHeight);\n    root.parent = null;\n    if (n > 0) throw new Error(\"cycle\");\n    return root;\n  }\n\n  stratify.id = function (x) {\n    return arguments.length ? (id = optional(x), stratify) : id;\n  };\n\n  stratify.parentId = function (x) {\n    return arguments.length ? (parentId = optional(x), stratify) : parentId;\n  };\n\n  stratify.path = function (x) {\n    return arguments.length ? (path = optional(x), stratify) : path;\n  };\n\n  return stratify;\n} // To normalize a path, we coerce to a string, strip the trailing slash if any\n// (as long as the trailing slash is not immediately preceded by another slash),\n// and add leading slash if missing.\n\nfunction normalize(path) {\n  path = `${path}`;\n  let i = path.length;\n  if (slash(path, i - 1) && !slash(path, i - 2)) path = path.slice(0, -1);\n  return path[0] === \"/\" ? path : `/${path}`;\n} // Walk backwards to find the first slash that is not the leading slash, e.g.:\n// \"/foo/bar\" ⇥ \"/foo\", \"/foo\" ⇥ \"/\", \"/\" ↦ \"\". (The root is special-cased\n// because the id of the root must be a truthy value.)\n\n\nfunction parentof(path) {\n  let i = path.length;\n  if (i < 2) return \"\";\n\n  while (--i > 1) if (slash(path, i)) break;\n\n  return path.slice(0, i);\n} // Slashes can be escaped; to determine whether a slash is a path delimiter, we\n// count the number of preceding backslashes escaping the forward slash: an odd\n// number indicates an escaped forward slash.\n\n\nfunction slash(path, i) {\n  if (path[i] === \"/\") {\n    let k = 0;\n\n    while (i > 0 && path[--i] === \"\\\\\") ++k;\n\n    if ((k & 1) === 0) return true;\n  }\n\n  return false;\n}","map":{"version":3,"names":["optional","Node","computeHeight","preroot","depth","ambiguous","imputed","defaultId","d","id","defaultParentId","parentId","path","stratify","data","nodes","Array","from","currentId","currentParentId","n","i","root","parent","node","nodeId","nodeKey","nodeByKey","Map","I","map","normalize","P","parentof","S","Set","add","has","push","_","length","set","get","Error","children","eachBefore","x","arguments","slash","slice","k"],"sources":["/home/aurimas/coding/idendro/frontend/node_modules/d3-hierarchy/src/stratify.js"],"sourcesContent":["import {optional} from \"./accessors.js\";\nimport {Node, computeHeight} from \"./hierarchy/index.js\";\n\nvar preroot = {depth: -1},\n    ambiguous = {},\n    imputed = {};\n\nfunction defaultId(d) {\n  return d.id;\n}\n\nfunction defaultParentId(d) {\n  return d.parentId;\n}\n\nexport default function() {\n  var id = defaultId,\n      parentId = defaultParentId,\n      path;\n\n  function stratify(data) {\n    var nodes = Array.from(data),\n        currentId = id,\n        currentParentId = parentId,\n        n,\n        d,\n        i,\n        root,\n        parent,\n        node,\n        nodeId,\n        nodeKey,\n        nodeByKey = new Map;\n\n    if (path != null) {\n      const I = nodes.map((d, i) => normalize(path(d, i, data)));\n      const P = I.map(parentof);\n      const S = new Set(I).add(\"\");\n      for (const i of P) {\n        if (!S.has(i)) {\n          S.add(i);\n          I.push(i);\n          P.push(parentof(i));\n          nodes.push(imputed);\n        }\n      }\n      currentId = (_, i) => I[i];\n      currentParentId = (_, i) => P[i];\n    }\n\n    for (i = 0, n = nodes.length; i < n; ++i) {\n      d = nodes[i], node = nodes[i] = new Node(d);\n      if ((nodeId = currentId(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = node.id = nodeId;\n        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);\n      }\n      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += \"\")) {\n        node.parent = nodeId;\n      }\n    }\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n      if (nodeId = node.parent) {\n        parent = nodeByKey.get(nodeId);\n        if (!parent) throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous) throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children) parent.children.push(node);\n        else parent.children = [node];\n        node.parent = parent;\n      } else {\n        if (root) throw new Error(\"multiple roots\");\n        root = node;\n      }\n    }\n\n    if (!root) throw new Error(\"no root\");\n\n    // When imputing internal nodes, only introduce roots if needed.\n    // Then replace the imputed marker data with null.\n    if (path != null) {\n      while (root.data === imputed && root.children.length === 1) {\n        root = root.children[0], --n;\n      }\n      for (let i = nodes.length - 1; i >= 0; --i) {\n        node = nodes[i];\n        if (node.data !== imputed) break;\n        node.data = null;\n      }\n    }\n\n    root.parent = preroot;\n    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);\n    root.parent = null;\n    if (n > 0) throw new Error(\"cycle\");\n\n    return root;\n  }\n\n  stratify.id = function(x) {\n    return arguments.length ? (id = optional(x), stratify) : id;\n  };\n\n  stratify.parentId = function(x) {\n    return arguments.length ? (parentId = optional(x), stratify) : parentId;\n  };\n\n  stratify.path = function(x) {\n    return arguments.length ? (path = optional(x), stratify) : path;\n  };\n\n  return stratify;\n}\n\n// To normalize a path, we coerce to a string, strip the trailing slash if any\n// (as long as the trailing slash is not immediately preceded by another slash),\n// and add leading slash if missing.\nfunction normalize(path) {\n  path = `${path}`;\n  let i = path.length;\n  if (slash(path, i - 1) && !slash(path, i - 2)) path = path.slice(0, -1);\n  return path[0] === \"/\" ? path : `/${path}`;\n}\n\n// Walk backwards to find the first slash that is not the leading slash, e.g.:\n// \"/foo/bar\" ⇥ \"/foo\", \"/foo\" ⇥ \"/\", \"/\" ↦ \"\". (The root is special-cased\n// because the id of the root must be a truthy value.)\nfunction parentof(path) {\n  let i = path.length;\n  if (i < 2) return \"\";\n  while (--i > 1) if (slash(path, i)) break;\n  return path.slice(0, i);\n}\n\n// Slashes can be escaped; to determine whether a slash is a path delimiter, we\n// count the number of preceding backslashes escaping the forward slash: an odd\n// number indicates an escaped forward slash.\nfunction slash(path, i) {\n  if (path[i] === \"/\") {\n    let k = 0;\n    while (i > 0 && path[--i] === \"\\\\\") ++k;\n    if ((k & 1) === 0) return true;\n  }\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}