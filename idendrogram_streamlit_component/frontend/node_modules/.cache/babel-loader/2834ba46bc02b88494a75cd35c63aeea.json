{"ast":null,"code":"import { dispatch } from \"d3-dispatch\";\nimport { timer, timeout } from \"d3-timer\";\nvar emptyOn = dispatch(\"start\", \"end\", \"cancel\", \"interrupt\");\nvar emptyTween = [];\nexport var CREATED = 0;\nexport var SCHEDULED = 1;\nexport var STARTING = 2;\nexport var STARTED = 3;\nexport var RUNNING = 4;\nexport var ENDING = 5;\nexport var ENDED = 6;\nexport default function (node, name, id, index, group, timing) {\n  var schedules = node.__transition;\n  if (!schedules) node.__transition = {};else if (id in schedules) return;\n  create(node, id, {\n    name: name,\n    index: index,\n    // For context during callback.\n    group: group,\n    // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n}\nexport function init(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > CREATED) throw new Error(\"too late; already scheduled\");\n  return schedule;\n}\nexport function set(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > STARTED) throw new Error(\"too late; already running\");\n  return schedule;\n}\nexport function get(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id])) throw new Error(\"transition not found\");\n  return schedule;\n}\n\nfunction create(node, id, self) {\n  var schedules = node.__transition,\n      tween; // Initialize the self timer when the transition is created.\n  // Note the actual delay is not known until the first callback!\n\n  schedules[id] = self;\n  self.timer = timer(schedule, 0, self.time);\n\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start, self.delay, self.time); // If the elapsed delay is less than our first sleep, start immediately.\n\n    if (self.delay <= elapsed) start(elapsed - self.delay);\n  }\n\n  function start(elapsed) {\n    var i, j, n, o; // If the state is not SCHEDULED, then we previously errored on start.\n\n    if (self.state !== SCHEDULED) return stop();\n\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name) continue; // While this element already has a starting transition during this frame,\n      // defer starting an interrupting transition until that transition has a\n      // chance to tick (and possibly end); see d3/d3-transition#54!\n\n      if (o.state === STARTED) return timeout(start); // Interrupt the active transition, if any.\n\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      } // Cancel any pre-empted transitions.\n      else if (+i < id) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"cancel\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n    } // Defer the first tick to end of the current frame; see d3/d3#1576.\n    // Note the transition may be canceled after start and before the first tick!\n    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n    // Assuming this is successful, subsequent callbacks go straight to tick.\n\n\n    timeout(function () {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    }); // Dispatch the start event.\n    // Note this must be done before the tween are initialized.\n\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING) return; // interrupted\n\n    self.state = STARTED; // Initialize the tween, deleting null tween.\n\n    tween = new Array(n = self.tween.length);\n\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n\n    tween.length = j + 1;\n  }\n\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),\n        i = -1,\n        n = tween.length;\n\n    while (++i < n) {\n      tween[i].call(node, t);\n    } // Dispatch the end event.\n\n\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id];\n\n    for (var i in schedules) return; // eslint-disable-line no-unused-vars\n\n\n    delete node.__transition;\n  }\n}","map":{"version":3,"names":["dispatch","timer","timeout","emptyOn","emptyTween","CREATED","SCHEDULED","STARTING","STARTED","RUNNING","ENDING","ENDED","node","name","id","index","group","timing","schedules","__transition","create","on","tween","time","delay","duration","ease","state","init","schedule","get","Error","set","self","elapsed","restart","start","i","j","n","o","stop","call","__data__","tick","Array","length","value","t"],"sources":["/home/aurimas/coding/idendro-streamlit/idendrogram_streamlit_component/frontend/node_modules/d3-transition/src/transition/schedule.js"],"sourcesContent":["import {dispatch} from \"d3-dispatch\";\nimport {timer, timeout} from \"d3-timer\";\n\nvar emptyOn = dispatch(\"start\", \"end\", \"cancel\", \"interrupt\");\nvar emptyTween = [];\n\nexport var CREATED = 0;\nexport var SCHEDULED = 1;\nexport var STARTING = 2;\nexport var STARTED = 3;\nexport var RUNNING = 4;\nexport var ENDING = 5;\nexport var ENDED = 6;\n\nexport default function(node, name, id, index, group, timing) {\n  var schedules = node.__transition;\n  if (!schedules) node.__transition = {};\n  else if (id in schedules) return;\n  create(node, id, {\n    name: name,\n    index: index, // For context during callback.\n    group: group, // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n}\n\nexport function init(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > CREATED) throw new Error(\"too late; already scheduled\");\n  return schedule;\n}\n\nexport function set(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > STARTED) throw new Error(\"too late; already running\");\n  return schedule;\n}\n\nexport function get(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id])) throw new Error(\"transition not found\");\n  return schedule;\n}\n\nfunction create(node, id, self) {\n  var schedules = node.__transition,\n      tween;\n\n  // Initialize the self timer when the transition is created.\n  // Note the actual delay is not known until the first callback!\n  schedules[id] = self;\n  self.timer = timer(schedule, 0, self.time);\n\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start, self.delay, self.time);\n\n    // If the elapsed delay is less than our first sleep, start immediately.\n    if (self.delay <= elapsed) start(elapsed - self.delay);\n  }\n\n  function start(elapsed) {\n    var i, j, n, o;\n\n    // If the state is not SCHEDULED, then we previously errored on start.\n    if (self.state !== SCHEDULED) return stop();\n\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name) continue;\n\n      // While this element already has a starting transition during this frame,\n      // defer starting an interrupting transition until that transition has a\n      // chance to tick (and possibly end); see d3/d3-transition#54!\n      if (o.state === STARTED) return timeout(start);\n\n      // Interrupt the active transition, if any.\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n\n      // Cancel any pre-empted transitions.\n      else if (+i < id) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"cancel\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n    }\n\n    // Defer the first tick to end of the current frame; see d3/d3#1576.\n    // Note the transition may be canceled after start and before the first tick!\n    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n    // Assuming this is successful, subsequent callbacks go straight to tick.\n    timeout(function() {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    });\n\n    // Dispatch the start event.\n    // Note this must be done before the tween are initialized.\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING) return; // interrupted\n    self.state = STARTED;\n\n    // Initialize the tween, deleting null tween.\n    tween = new Array(n = self.tween.length);\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n    tween.length = j + 1;\n  }\n\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),\n        i = -1,\n        n = tween.length;\n\n    while (++i < n) {\n      tween[i].call(node, t);\n    }\n\n    // Dispatch the end event.\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id];\n    for (var i in schedules) return; // eslint-disable-line no-unused-vars\n    delete node.__transition;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}