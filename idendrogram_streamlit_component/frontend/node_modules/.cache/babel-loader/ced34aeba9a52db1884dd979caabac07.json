{"ast":null,"code":"import { Node } from \"./hierarchy/index.js\";\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n} // function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\n\n\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n} // This function works analogously to nextLeft.\n\n\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n} // Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\n\n\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n} // All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\n\n\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n} // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n// returns the specified (default) ancestor.\n\n\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n\n  this.a = this; // ancestor\n\n  this.z = 0; // prelim\n\n  this.m = 0; // mod\n\n  this.c = 0; // change\n\n  this.s = 0; // shift\n\n  this.t = null; // thread\n\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n} // Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\n\n\nexport default function () {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root); // Compute the layout using Buchheim et al.’s algorithm.\n\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk); // If a fixed node size is specified, scale x and y.\n\n    if (nodeSize) root.eachBefore(sizeNode); // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function (node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function (node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n    return root;\n  } // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n\n\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  } // Computes all real x-coordinates by summing up the modifiers recursively.\n\n\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  } // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n\n\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function (x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function (x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];\n  };\n\n  tree.nodeSize = function (x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;\n  };\n\n  return tree;\n}","map":{"version":3,"names":["Node","defaultSeparation","a","b","parent","nextLeft","v","children","t","nextRight","length","moveSubtree","wm","wp","shift","change","i","c","s","z","m","executeShifts","w","nextAncestor","vim","ancestor","TreeNode","node","_","A","prototype","Object","create","treeRoot","root","tree","nodes","child","n","pop","Array","push","separation","dx","dy","nodeSize","eachAfter","firstWalk","eachBefore","secondWalk","sizeNode","left","right","bottom","x","depth","tx","kx","ky","y","siblings","midpoint","apportion","vip","vop","vom","sip","sop","sim","som","arguments","size"],"sources":["/home/aurimas/coding/idendro-streamlit/idendrogram_streamlit_component/frontend/node_modules/d3-hierarchy/src/tree.js"],"sourcesContent":["import {Node} from \"./hierarchy/index.js\";\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\n// function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n}\n\n// This function works analogously to nextLeft.\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n}\n\n// Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\n\n// All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\n\n// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n// returns the specified (default) ancestor.\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n  this.a = this; // ancestor\n  this.z = 0; // prelim\n  this.m = 0; // mod\n  this.c = 0; // change\n  this.s = 0; // shift\n  this.t = null; // thread\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n}\n\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nexport default function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root);\n\n    // Compute the layout using Buchheim et al.’s algorithm.\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n\n    // If a fixed node size is specified, scale x and y.\n    if (nodeSize) root.eachBefore(sizeNode);\n\n    // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function(node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n\n    return root;\n  }\n\n  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  }\n\n  // Computes all real x-coordinates by summing up the modifiers recursively.\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  }\n\n  // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function(x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n  };\n\n  tree.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return tree;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}