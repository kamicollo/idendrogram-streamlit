{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/aurimas/coding/idendro/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/home/aurimas/coding/idendro/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/aurimas/coding/idendro/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(flatIterable);\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nimport Delaunator from \"delaunator\";\nimport Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\nimport Voronoi from \"./voronoi.js\";\nvar tau = 2 * Math.PI,\n    pow = Math.pow;\n\nfunction pointX(p) {\n  return p[0];\n}\n\nfunction pointY(p) {\n  return p[1];\n} // A triangulation is collinear if all its triangles have a non-null area\n\n\nfunction collinear(d) {\n  var triangles = d.triangles,\n      coords = d.coords;\n\n  for (var i = 0; i < triangles.length; i += 3) {\n    var a = 2 * triangles[i],\n        b = 2 * triangles[i + 1],\n        c = 2 * triangles[i + 2],\n        cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1]) - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);\n    if (cross > 1e-10) return false;\n  }\n\n  return true;\n}\n\nfunction jitter(x, y, r) {\n  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];\n}\n\nvar Delaunay = /*#__PURE__*/function () {\n  function Delaunay(points) {\n    _classCallCheck(this, Delaunay);\n\n    this._delaunator = new Delaunator(points);\n    this.inedges = new Int32Array(points.length / 2);\n    this._hullIndex = new Int32Array(points.length / 2);\n    this.points = this._delaunator.coords;\n\n    this._init();\n  }\n\n  _createClass(Delaunay, [{\n    key: \"update\",\n    value: function update() {\n      this._delaunator.update();\n\n      this._init();\n\n      return this;\n    }\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var d = this._delaunator,\n          points = this.points; // check for collinear\n\n      if (d.hull && d.hull.length > 2 && collinear(d)) {\n        this.collinear = Int32Array.from({\n          length: points.length / 2\n        }, function (_, i) {\n          return i;\n        }).sort(function (i, j) {\n          return points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1];\n        }); // for exact neighbors\n\n        var e = this.collinear[0],\n            f = this.collinear[this.collinear.length - 1],\n            bounds = [points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1]],\n            r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);\n\n        for (var i = 0, n = points.length / 2; i < n; ++i) {\n          var p = jitter(points[2 * i], points[2 * i + 1], r);\n          points[2 * i] = p[0];\n          points[2 * i + 1] = p[1];\n        }\n\n        this._delaunator = new Delaunator(points);\n      } else {\n        delete this.collinear;\n      }\n\n      var halfedges = this.halfedges = this._delaunator.halfedges;\n      var hull = this.hull = this._delaunator.hull;\n      var triangles = this.triangles = this._delaunator.triangles;\n      var inedges = this.inedges.fill(-1);\n\n      var hullIndex = this._hullIndex.fill(-1); // Compute an index from each point to an (arbitrary) incoming halfedge\n      // Used to give the first neighbor of each point; for this reason,\n      // on the hull we give priority to exterior halfedges\n\n\n      for (var _e = 0, _n = halfedges.length; _e < _n; ++_e) {\n        var _p = triangles[_e % 3 === 2 ? _e - 2 : _e + 1];\n        if (halfedges[_e] === -1 || inedges[_p] === -1) inedges[_p] = _e;\n      }\n\n      for (var _i = 0, _n2 = hull.length; _i < _n2; ++_i) {\n        hullIndex[hull[_i]] = _i;\n      } // degenerate case: 1 or 2 (distinct) points\n\n\n      if (hull.length <= 2 && hull.length > 0) {\n        this.triangles = new Int32Array(3).fill(-1);\n        this.halfedges = new Int32Array(3).fill(-1);\n        this.triangles[0] = hull[0];\n        inedges[hull[0]] = 1;\n\n        if (hull.length === 2) {\n          inedges[hull[1]] = 0;\n          this.triangles[1] = hull[1];\n          this.triangles[2] = hull[1];\n        }\n      }\n    }\n  }, {\n    key: \"voronoi\",\n    value: function voronoi(bounds) {\n      return new Voronoi(this, bounds);\n    }\n  }, {\n    key: \"neighbors\",\n    value: /*#__PURE__*/_regeneratorRuntime().mark(function neighbors(i) {\n      var inedges, hull, _hullIndex, halfedges, triangles, collinear, l, e0, e, p0, p;\n\n      return _regeneratorRuntime().wrap(function neighbors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              inedges = this.inedges, hull = this.hull, _hullIndex = this._hullIndex, halfedges = this.halfedges, triangles = this.triangles, collinear = this.collinear; // degenerate case with several collinear points\n\n              if (!collinear) {\n                _context.next = 10;\n                break;\n              }\n\n              l = collinear.indexOf(i);\n\n              if (!(l > 0)) {\n                _context.next = 6;\n                break;\n              }\n\n              _context.next = 6;\n              return collinear[l - 1];\n\n            case 6:\n              if (!(l < collinear.length - 1)) {\n                _context.next = 9;\n                break;\n              }\n\n              _context.next = 9;\n              return collinear[l + 1];\n\n            case 9:\n              return _context.abrupt(\"return\");\n\n            case 10:\n              e0 = inedges[i];\n\n              if (!(e0 === -1)) {\n                _context.next = 13;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 13:\n              // coincident point\n              e = e0, p0 = -1;\n\n            case 14:\n              _context.next = 16;\n              return p0 = triangles[e];\n\n            case 16:\n              e = e % 3 === 2 ? e - 2 : e + 1;\n\n              if (!(triangles[e] !== i)) {\n                _context.next = 19;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 19:\n              // bad triangulation\n              e = halfedges[e];\n\n              if (!(e === -1)) {\n                _context.next = 26;\n                break;\n              }\n\n              p = hull[(_hullIndex[i] + 1) % hull.length];\n\n              if (!(p !== p0)) {\n                _context.next = 25;\n                break;\n              }\n\n              _context.next = 25;\n              return p;\n\n            case 25:\n              return _context.abrupt(\"return\");\n\n            case 26:\n              if (e !== e0) {\n                _context.next = 14;\n                break;\n              }\n\n            case 27:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, neighbors, this);\n    })\n  }, {\n    key: \"find\",\n    value: function find(x, y) {\n      var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;\n      var i0 = i;\n      var c;\n\n      while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) {\n        i = c;\n      }\n\n      return c;\n    }\n  }, {\n    key: \"_step\",\n    value: function _step(i, x, y) {\n      var inedges = this.inedges,\n          hull = this.hull,\n          _hullIndex = this._hullIndex,\n          halfedges = this.halfedges,\n          triangles = this.triangles,\n          points = this.points;\n      if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);\n      var c = i;\n      var dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);\n      var e0 = inedges[i];\n      var e = e0;\n\n      do {\n        var t = triangles[e];\n        var dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);\n        if (dt < dc) dc = dt, c = t;\n        e = e % 3 === 2 ? e - 2 : e + 1;\n        if (triangles[e] !== i) break; // bad triangulation\n\n        e = halfedges[e];\n\n        if (e === -1) {\n          e = hull[(_hullIndex[i] + 1) % hull.length];\n\n          if (e !== t) {\n            if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;\n          }\n\n          break;\n        }\n      } while (e !== e0);\n\n      return c;\n    }\n  }, {\n    key: \"render\",\n    value: function render(context) {\n      var buffer = context == null ? context = new Path() : undefined;\n      var points = this.points,\n          halfedges = this.halfedges,\n          triangles = this.triangles;\n\n      for (var i = 0, n = halfedges.length; i < n; ++i) {\n        var j = halfedges[i];\n        if (j < i) continue;\n        var ti = triangles[i] * 2;\n        var tj = triangles[j] * 2;\n        context.moveTo(points[ti], points[ti + 1]);\n        context.lineTo(points[tj], points[tj + 1]);\n      }\n\n      this.renderHull(context);\n      return buffer && buffer.value();\n    }\n  }, {\n    key: \"renderPoints\",\n    value: function renderPoints(context, r) {\n      if (r === undefined && (!context || typeof context.moveTo !== \"function\")) r = context, context = null;\n      r = r == undefined ? 2 : +r;\n      var buffer = context == null ? context = new Path() : undefined;\n      var points = this.points;\n\n      for (var i = 0, n = points.length; i < n; i += 2) {\n        var x = points[i],\n            y = points[i + 1];\n        context.moveTo(x + r, y);\n        context.arc(x, y, r, 0, tau);\n      }\n\n      return buffer && buffer.value();\n    }\n  }, {\n    key: \"renderHull\",\n    value: function renderHull(context) {\n      var buffer = context == null ? context = new Path() : undefined;\n      var hull = this.hull,\n          points = this.points;\n      var h = hull[0] * 2,\n          n = hull.length;\n      context.moveTo(points[h], points[h + 1]);\n\n      for (var i = 1; i < n; ++i) {\n        var _h = 2 * hull[i];\n\n        context.lineTo(points[_h], points[_h + 1]);\n      }\n\n      context.closePath();\n      return buffer && buffer.value();\n    }\n  }, {\n    key: \"hullPolygon\",\n    value: function hullPolygon() {\n      var polygon = new Polygon();\n      this.renderHull(polygon);\n      return polygon.value();\n    }\n  }, {\n    key: \"renderTriangle\",\n    value: function renderTriangle(i, context) {\n      var buffer = context == null ? context = new Path() : undefined;\n      var points = this.points,\n          triangles = this.triangles;\n      var t0 = triangles[i *= 3] * 2;\n      var t1 = triangles[i + 1] * 2;\n      var t2 = triangles[i + 2] * 2;\n      context.moveTo(points[t0], points[t0 + 1]);\n      context.lineTo(points[t1], points[t1 + 1]);\n      context.lineTo(points[t2], points[t2 + 1]);\n      context.closePath();\n      return buffer && buffer.value();\n    }\n  }, {\n    key: \"trianglePolygons\",\n    value: /*#__PURE__*/_regeneratorRuntime().mark(function trianglePolygons() {\n      var triangles, i, n;\n      return _regeneratorRuntime().wrap(function trianglePolygons$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              triangles = this.triangles;\n              i = 0, n = triangles.length / 3;\n\n            case 2:\n              if (!(i < n)) {\n                _context2.next = 8;\n                break;\n              }\n\n              _context2.next = 5;\n              return this.trianglePolygon(i);\n\n            case 5:\n              ++i;\n              _context2.next = 2;\n              break;\n\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, trianglePolygons, this);\n    })\n  }, {\n    key: \"trianglePolygon\",\n    value: function trianglePolygon(i) {\n      var polygon = new Polygon();\n      this.renderTriangle(i, polygon);\n      return polygon.value();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(points) {\n      var fx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : pointX;\n      var fy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : pointY;\n      var that = arguments.length > 3 ? arguments[3] : undefined;\n      return new Delaunay(\"length\" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));\n    }\n  }]);\n\n  return Delaunay;\n}();\n\nexport { Delaunay as default };\n\nfunction flatArray(points, fx, fy, that) {\n  var n = points.length;\n  var array = new Float64Array(n * 2);\n\n  for (var i = 0; i < n; ++i) {\n    var p = points[i];\n    array[i * 2] = fx.call(that, p, i, points);\n    array[i * 2 + 1] = fy.call(that, p, i, points);\n  }\n\n  return array;\n}\n\nfunction flatIterable(points, fx, fy, that) {\n  var i, _iterator, _step2, p;\n\n  return _regeneratorRuntime().wrap(function flatIterable$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          i = 0;\n          _iterator = _createForOfIteratorHelper(points);\n          _context3.prev = 2;\n\n          _iterator.s();\n\n        case 4:\n          if ((_step2 = _iterator.n()).done) {\n            _context3.next = 13;\n            break;\n          }\n\n          p = _step2.value;\n          _context3.next = 8;\n          return fx.call(that, p, i, points);\n\n        case 8:\n          _context3.next = 10;\n          return fy.call(that, p, i, points);\n\n        case 10:\n          ++i;\n\n        case 11:\n          _context3.next = 4;\n          break;\n\n        case 13:\n          _context3.next = 18;\n          break;\n\n        case 15:\n          _context3.prev = 15;\n          _context3.t0 = _context3[\"catch\"](2);\n\n          _iterator.e(_context3.t0);\n\n        case 18:\n          _context3.prev = 18;\n\n          _iterator.f();\n\n          return _context3.finish(18);\n\n        case 21:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked, null, [[2, 15, 18, 21]]);\n}","map":{"version":3,"names":["flatIterable","Delaunator","Path","Polygon","Voronoi","tau","Math","PI","pow","pointX","p","pointY","collinear","d","triangles","coords","i","length","a","b","c","cross","jitter","x","y","r","sin","cos","Delaunay","points","_delaunator","inedges","Int32Array","_hullIndex","_init","update","hull","from","_","sort","j","e","f","bounds","hypot","n","halfedges","fill","hullIndex","l","indexOf","e0","p0","i0","_step","dc","t","dt","context","buffer","undefined","ti","tj","moveTo","lineTo","renderHull","value","arc","h","closePath","polygon","t0","t1","t2","trianglePolygon","renderTriangle","fx","fy","that","flatArray","Float64Array","array","call"],"sources":["/home/aurimas/coding/idendro/frontend/node_modules/d3-delaunay/src/delaunay.js"],"sourcesContent":["import Delaunator from \"delaunator\";\nimport Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\nimport Voronoi from \"./voronoi.js\";\n\nconst tau = 2 * Math.PI, pow = Math.pow;\n\nfunction pointX(p) {\n  return p[0];\n}\n\nfunction pointY(p) {\n  return p[1];\n}\n\n// A triangulation is collinear if all its triangles have a non-null area\nfunction collinear(d) {\n  const {triangles, coords} = d;\n  for (let i = 0; i < triangles.length; i += 3) {\n    const a = 2 * triangles[i],\n          b = 2 * triangles[i + 1],\n          c = 2 * triangles[i + 2],\n          cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])\n                - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);\n    if (cross > 1e-10) return false;\n  }\n  return true;\n}\n\nfunction jitter(x, y, r) {\n  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];\n}\n\nexport default class Delaunay {\n  static from(points, fx = pointX, fy = pointY, that) {\n    return new Delaunay(\"length\" in points\n        ? flatArray(points, fx, fy, that)\n        : Float64Array.from(flatIterable(points, fx, fy, that)));\n  }\n  constructor(points) {\n    this._delaunator = new Delaunator(points);\n    this.inedges = new Int32Array(points.length / 2);\n    this._hullIndex = new Int32Array(points.length / 2);\n    this.points = this._delaunator.coords;\n    this._init();\n  }\n  update() {\n    this._delaunator.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const d = this._delaunator, points = this.points;\n\n    // check for collinear\n    if (d.hull && d.hull.length > 2 && collinear(d)) {\n      this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)\n        .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors\n      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],\n        bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],\n        r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);\n      for (let i = 0, n = points.length / 2; i < n; ++i) {\n        const p = jitter(points[2 * i], points[2 * i + 1], r);\n        points[2 * i] = p[0];\n        points[2 * i + 1] = p[1];\n      }\n      this._delaunator = new Delaunator(points);\n    } else {\n      delete this.collinear;\n    }\n\n    const halfedges = this.halfedges = this._delaunator.halfedges;\n    const hull = this.hull = this._delaunator.hull;\n    const triangles = this.triangles = this._delaunator.triangles;\n    const inedges = this.inedges.fill(-1);\n    const hullIndex = this._hullIndex.fill(-1);\n\n    // Compute an index from each point to an (arbitrary) incoming halfedge\n    // Used to give the first neighbor of each point; for this reason,\n    // on the hull we give priority to exterior halfedges\n    for (let e = 0, n = halfedges.length; e < n; ++e) {\n      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];\n      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;\n    }\n    for (let i = 0, n = hull.length; i < n; ++i) {\n      hullIndex[hull[i]] = i;\n    }\n\n    // degenerate case: 1 or 2 (distinct) points\n    if (hull.length <= 2 && hull.length > 0) {\n      this.triangles = new Int32Array(3).fill(-1);\n      this.halfedges = new Int32Array(3).fill(-1);\n      this.triangles[0] = hull[0];\n      inedges[hull[0]] = 1;\n      if (hull.length === 2) {\n        inedges[hull[1]] = 0;\n        this.triangles[1] = hull[1];\n        this.triangles[2] = hull[1];\n      }\n    }\n  }\n  voronoi(bounds) {\n    return new Voronoi(this, bounds);\n  }\n  *neighbors(i) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;\n\n    // degenerate case with several collinear points\n    if (collinear) {\n      const l = collinear.indexOf(i);\n      if (l > 0) yield collinear[l - 1];\n      if (l < collinear.length - 1) yield collinear[l + 1];\n      return;\n    }\n\n    const e0 = inedges[i];\n    if (e0 === -1) return; // coincident point\n    let e = e0, p0 = -1;\n    do {\n      yield p0 = triangles[e];\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) return; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        const p = hull[(_hullIndex[i] + 1) % hull.length];\n        if (p !== p0) yield p;\n        return;\n      }\n    } while (e !== e0);\n  }\n  find(x, y, i = 0) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;\n    const i0 = i;\n    let c;\n    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;\n    return c;\n  }\n  _step(i, x, y) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;\n    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);\n    let c = i;\n    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);\n    const e0 = inedges[i];\n    let e = e0;\n    do {\n      let t = triangles[e];\n      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);\n      if (dt < dc) dc = dt, c = t;\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        e = hull[(_hullIndex[i] + 1) % hull.length];\n        if (e !== t) {\n          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;\n        }\n        break;\n      }\n    } while (e !== e0);\n    return c;\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, halfedges, triangles} = this;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = triangles[i] * 2;\n      const tj = triangles[j] * 2;\n      context.moveTo(points[ti], points[ti + 1]);\n      context.lineTo(points[tj], points[tj + 1]);\n    }\n    this.renderHull(context);\n    return buffer && buffer.value();\n  }\n  renderPoints(context, r) {\n    if (r === undefined && (!context || typeof context.moveTo !== \"function\")) r = context, context = null;\n    r = r == undefined ? 2 : +r;\n    const buffer = context == null ? context = new Path : undefined;\n    const {points} = this;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i], y = points[i + 1];\n      context.moveTo(x + r, y);\n      context.arc(x, y, r, 0, tau);\n    }\n    return buffer && buffer.value();\n  }\n  renderHull(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {hull, points} = this;\n    const h = hull[0] * 2, n = hull.length;\n    context.moveTo(points[h], points[h + 1]);\n    for (let i = 1; i < n; ++i) {\n      const h = 2 * hull[i];\n      context.lineTo(points[h], points[h + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  hullPolygon() {\n    const polygon = new Polygon;\n    this.renderHull(polygon);\n    return polygon.value();\n  }\n  renderTriangle(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, triangles} = this;\n    const t0 = triangles[i *= 3] * 2;\n    const t1 = triangles[i + 1] * 2;\n    const t2 = triangles[i + 2] * 2;\n    context.moveTo(points[t0], points[t0 + 1]);\n    context.lineTo(points[t1], points[t1 + 1]);\n    context.lineTo(points[t2], points[t2 + 1]);\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *trianglePolygons() {\n    const {triangles} = this;\n    for (let i = 0, n = triangles.length / 3; i < n; ++i) {\n      yield this.trianglePolygon(i);\n    }\n  }\n  trianglePolygon(i) {\n    const polygon = new Polygon;\n    this.renderTriangle(i, polygon);\n    return polygon.value();\n  }\n}\n\nfunction flatArray(points, fx, fy, that) {\n  const n = points.length;\n  const array = new Float64Array(n * 2);\n  for (let i = 0; i < n; ++i) {\n    const p = points[i];\n    array[i * 2] = fx.call(that, p, i, points);\n    array[i * 2 + 1] = fy.call(that, p, i, points);\n  }\n  return array;\n}\n\nfunction* flatIterable(points, fx, fy, that) {\n  let i = 0;\n  for (const p of points) {\n    yield fx.call(that, p, i, points);\n    yield fy.call(that, p, i, points);\n    ++i;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}