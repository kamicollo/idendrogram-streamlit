{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/aurimas/coding/idendro/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/home/aurimas/coding/idendro/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/aurimas/coding/idendro/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/aurimas/coding/idendro/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/aurimas/coding/idendro/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/aurimas/coding/idendro/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { clampRange } from '../util/vector';\nimport { DataType } from '../type';\nimport { selectChunkArgs } from '../util/args';\nimport { AbstractVector, Vector } from '../vector';\n/** @ignore */\n\nexport var Chunked = /*#__PURE__*/function (_AbstractVector, _Symbol$iterator) {\n  _inherits(Chunked, _AbstractVector);\n\n  var _super = _createSuper(Chunked);\n\n  function Chunked(type) {\n    var _this;\n\n    var chunks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var offsets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : calculateOffsets(chunks);\n\n    _classCallCheck(this, Chunked);\n\n    _this = _super.call(this);\n    _this._nullCount = -1;\n    _this._type = type;\n    _this._chunks = chunks;\n    _this._chunkOffsets = offsets;\n    _this._length = offsets[offsets.length - 1];\n    _this._numChildren = (_this._type.children || []).length;\n    return _this;\n  }\n  /** @nocollapse */\n\n\n  _createClass(Chunked, [{\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._length;\n    }\n  }, {\n    key: \"chunks\",\n    get: function get() {\n      return this._chunks;\n    }\n  }, {\n    key: \"typeId\",\n    get: function get() {\n      return this._type.typeId;\n    }\n  }, {\n    key: \"VectorName\",\n    get: function get() {\n      return \"Chunked<\".concat(this._type, \">\");\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this._chunks[0] ? this._chunks[0].data : null;\n    }\n  }, {\n    key: \"ArrayType\",\n    get: function get() {\n      return this._type.ArrayType;\n    }\n  }, {\n    key: \"numChildren\",\n    get: function get() {\n      return this._numChildren;\n    }\n  }, {\n    key: \"stride\",\n    get: function get() {\n      return this._chunks[0] ? this._chunks[0].stride : 1;\n    }\n  }, {\n    key: \"byteLength\",\n    get: function get() {\n      return this._chunks.reduce(function (byteLength, chunk) {\n        return byteLength + chunk.byteLength;\n      }, 0);\n    }\n  }, {\n    key: \"nullCount\",\n    get: function get() {\n      var nullCount = this._nullCount;\n\n      if (nullCount < 0) {\n        this._nullCount = nullCount = this._chunks.reduce(function (x, _ref) {\n          var nullCount = _ref.nullCount;\n          return x + nullCount;\n        }, 0);\n      }\n\n      return nullCount;\n    }\n  }, {\n    key: \"indices\",\n    get: function get() {\n      if (DataType.isDictionary(this._type)) {\n        if (!this._indices) {\n          var _chunks2 = this._chunks;\n          this._indices = _chunks2.length === 1 ? _chunks2[0].indices : Chunked.concat.apply(Chunked, _toConsumableArray(_chunks2.map(function (x) {\n            return x.indices;\n          })));\n        }\n\n        return this._indices;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"dictionary\",\n    get: function get() {\n      if (DataType.isDictionary(this._type)) {\n        return this._chunks[this._chunks.length - 1].data.dictionary;\n      }\n\n      return null;\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {\n      var _iterator, _step, chunk;\n\n      return _regeneratorRuntime().wrap(function value$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iterator = _createForOfIteratorHelper(this._chunks);\n              _context.prev = 1;\n\n              _iterator.s();\n\n            case 3:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 8;\n                break;\n              }\n\n              chunk = _step.value;\n              return _context.delegateYield(chunk, \"t0\", 6);\n\n            case 6:\n              _context.next = 3;\n              break;\n\n            case 8:\n              _context.next = 13;\n              break;\n\n            case 10:\n              _context.prev = 10;\n              _context.t1 = _context[\"catch\"](1);\n\n              _iterator.e(_context.t1);\n\n            case 13:\n              _context.prev = 13;\n\n              _iterator.f();\n\n              return _context.finish(13);\n\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, value, this, [[1, 10, 13, 16]]);\n    })\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._chunks;\n      return new Chunked(this._type, chunks);\n    }\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      for (var _len = arguments.length, others = new Array(_len), _key = 0; _key < _len; _key++) {\n        others[_key] = arguments[_key];\n      }\n\n      return this.clone(Chunked.flatten.apply(Chunked, [this].concat(others)));\n    }\n  }, {\n    key: \"slice\",\n    value: function slice(begin, end) {\n      return clampRange(this, begin, end, this._sliceInternal);\n    }\n  }, {\n    key: \"getChildAt\",\n    value: function getChildAt(index) {\n      if (index < 0 || index >= this._numChildren) {\n        return null;\n      }\n\n      var columns = this._children || (this._children = []);\n      var child, field, chunks;\n\n      if (child = columns[index]) {\n        return child;\n      }\n\n      if (field = (this._type.children || [])[index]) {\n        chunks = this._chunks.map(function (vector) {\n          return vector.getChildAt(index);\n        }).filter(function (vec) {\n          return vec != null;\n        });\n\n        if (chunks.length > 0) {\n          return columns[index] = new Chunked(field.type, chunks);\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"search\",\n    value: function search(index, then) {\n      var idx = index; // binary search to find the child vector and value indices\n\n      var offsets = this._chunkOffsets,\n          rhs = offsets.length - 1; // return early if out of bounds, or if there's just one child\n\n      if (idx < 0) {\n        return null;\n      }\n\n      if (idx >= offsets[rhs]) {\n        return null;\n      }\n\n      if (rhs <= 1) {\n        return then ? then(this, 0, idx) : [0, idx];\n      }\n\n      var lhs = 0,\n          pos = 0,\n          mid = 0;\n\n      do {\n        if (lhs + 1 === rhs) {\n          return then ? then(this, lhs, idx - pos) : [lhs, idx - pos];\n        }\n\n        mid = lhs + (rhs - lhs) / 2 | 0;\n        idx >= offsets[mid] ? lhs = mid : rhs = mid;\n      } while (idx < offsets[rhs] && idx >= (pos = offsets[lhs]));\n\n      return null;\n    }\n  }, {\n    key: \"isValid\",\n    value: function isValid(index) {\n      return !!this.search(index, this.isValidInternal);\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      return this.search(index, this.getInternal);\n    }\n  }, {\n    key: \"set\",\n    value: function set(index, value) {\n      this.search(index, function (_ref2, i, j) {\n        var chunks = _ref2.chunks;\n        return chunks[i].set(j, value);\n      });\n    }\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(element, offset) {\n      var _this2 = this;\n\n      if (offset && typeof offset === 'number') {\n        return this.search(offset, function (self, i, j) {\n          return _this2.indexOfInternal(self, i, j, element);\n        });\n      }\n\n      return this.indexOfInternal(this, 0, Math.max(0, offset || 0), element);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      var chunks = this.chunks;\n      var n = chunks.length;\n      var ArrayType = this._type.ArrayType;\n\n      if (n <= 0) {\n        return new ArrayType(0);\n      }\n\n      if (n <= 1) {\n        return chunks[0].toArray();\n      }\n\n      var len = 0,\n          src = new Array(n);\n\n      for (var i = -1; ++i < n;) {\n        len += (src[i] = chunks[i].toArray()).length;\n      }\n\n      if (ArrayType !== src[0].constructor) {\n        ArrayType = src[0].constructor;\n      }\n\n      var dst = new ArrayType(len);\n      var set = ArrayType === Array ? arraySet : typedSet;\n\n      for (var _i = -1, idx = 0; ++_i < n;) {\n        idx = set(src[_i], dst, idx);\n      }\n\n      return dst;\n    }\n  }, {\n    key: \"getInternal\",\n    value: function getInternal(_ref3, i, j) {\n      var _chunks = _ref3._chunks;\n      return _chunks[i].get(j);\n    }\n  }, {\n    key: \"isValidInternal\",\n    value: function isValidInternal(_ref4, i, j) {\n      var _chunks = _ref4._chunks;\n      return _chunks[i].isValid(j);\n    }\n  }, {\n    key: \"indexOfInternal\",\n    value: function indexOfInternal(_ref5, chunkIndex, fromIndex, element) {\n      var _chunks = _ref5._chunks;\n      var i = chunkIndex - 1,\n          n = _chunks.length;\n      var start = fromIndex,\n          offset = 0,\n          found = -1;\n\n      while (++i < n) {\n        if (~(found = _chunks[i].indexOf(element, start))) {\n          return offset + found;\n        }\n\n        start = 0;\n        offset += _chunks[i].length;\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"_sliceInternal\",\n    value: function _sliceInternal(self, begin, end) {\n      var slices = [];\n      var chunks = self.chunks,\n          chunkOffsets = self._chunkOffsets;\n\n      for (var i = -1, n = chunks.length; ++i < n;) {\n        var chunk = chunks[i];\n        var chunkLength = chunk.length;\n        var chunkOffset = chunkOffsets[i]; // If the child is to the right of the slice boundary, we can stop\n\n        if (chunkOffset >= end) {\n          break;\n        } // If the child is to the left of of the slice boundary, exclude\n\n\n        if (begin >= chunkOffset + chunkLength) {\n          continue;\n        } // If the child is between both left and right boundaries, include w/o slicing\n\n\n        if (chunkOffset >= begin && chunkOffset + chunkLength <= end) {\n          slices.push(chunk);\n          continue;\n        } // If the child overlaps one of the slice boundaries, include that slice\n\n\n        var from = Math.max(0, begin - chunkOffset);\n        var to = Math.min(end - chunkOffset, chunkLength);\n        slices.push(chunk.slice(from, to));\n      }\n\n      return self.clone(slices);\n    }\n  }], [{\n    key: \"flatten\",\n    value: function flatten() {\n      for (var _len2 = arguments.length, vectors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        vectors[_key2] = arguments[_key2];\n      }\n\n      return selectChunkArgs(Vector, vectors);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      var chunks = Chunked.flatten.apply(Chunked, arguments);\n      return new Chunked(chunks[0].type, chunks);\n    }\n  }]);\n\n  return Chunked;\n}(AbstractVector, Symbol.iterator);\n/** @ignore */\n\nfunction calculateOffsets(vectors) {\n  var offsets = new Uint32Array((vectors || []).length + 1);\n  var offset = offsets[0] = 0,\n      length = offsets.length;\n\n  for (var index = 0; ++index < length;) {\n    offsets[index] = offset += vectors[index - 1].length;\n  }\n\n  return offsets;\n}\n/** @ignore */\n\n\nvar typedSet = function typedSet(src, dst, offset) {\n  dst.set(src, offset);\n  return offset + src.length;\n};\n/** @ignore */\n\n\nvar arraySet = function arraySet(src, dst, offset) {\n  var idx = offset;\n\n  for (var i = -1, n = src.length; ++i < n;) {\n    dst[idx++] = src[i];\n  }\n\n  return idx;\n};","map":{"version":3,"sources":["vector/chunked.ts"],"names":[],"mappings":";;;;;;;+CACA,oJ;;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA,SAAS,UAAT,QAA2B,gBAA3B;AACA,SAAS,QAAT,QAAqC,SAArC;AACA,SAAS,eAAT,QAAgC,cAAhC;AAEA,SAAS,cAAT,EAAyB,MAAzB,QAAuC,WAAvC;AAWA;;AACA,WAAa,OAAb;EAAA;;EAAA;;EAyBI,iBAAY,IAAZ,EAAiF;IAAA;;IAAA,IAA5D,MAA4D,uEAAtC,EAAsC;IAAA,IAAlC,OAAkC,uEAAxB,gBAAgB,CAAC,MAAD,CAAQ;;IAAA;;IAC7E;IAJM,MAAA,UAAA,GAAqB,CAAC,CAAtB;IAKN,MAAK,KAAL,GAAa,IAAb;IACA,MAAK,OAAL,GAAe,MAAf;IACA,MAAK,aAAL,GAAqB,OAArB;IACA,MAAK,OAAL,GAAe,OAAO,CAAC,OAAO,CAAC,MAAR,GAAiB,CAAlB,CAAtB;IACA,MAAK,YAAL,GAAoB,CAAC,MAAK,KAAL,CAAW,QAAX,IAAuB,EAAxB,EAA4B,MAAhD;IAN6E;EAOhF;EA1BD;;;EANJ;IAAA;IAAA,KAkCI,eAAe;MAAK,OAAO,KAAK,KAAZ;IAAoB;EAlC5C;IAAA;IAAA,KAmCI,eAAiB;MAAK,OAAO,KAAK,OAAZ;IAAsB;EAnChD;IAAA;IAAA,KAoCI,eAAiB;MAAK,OAAO,KAAK,OAAZ;IAAsB;EApChD;IAAA;IAAA,KAqCI,eAAiB;MAAiB,OAAO,KAAK,KAAL,CAAW,MAAlB;IAA2B;EArCjE;IAAA;IAAA,KAsCI,eAAqB;MAAK,yBAAkB,KAAK,KAAvB;IAAkC;EAtChE;IAAA;IAAA,KAuCI,eAAe;MACX,OAAO,KAAK,OAAL,CAAa,CAAb,IAAkB,KAAK,OAAL,CAAa,CAAb,EAAgB,IAAlC,GAA+C,IAAtD;IACH;EAzCL;IAAA;IAAA,KA2CI,eAAoB;MAAK,OAAO,KAAK,KAAL,CAAW,SAAlB;IAA8B;EA3C3D;IAAA;IAAA,KA4CI,eAAsB;MAAK,OAAO,KAAK,YAAZ;IAA2B;EA5C1D;IAAA;IAAA,KA6CI,eAAiB;MAAK,OAAO,KAAK,OAAL,CAAa,CAAb,IAAkB,KAAK,OAAL,CAAa,CAAb,EAAgB,MAAlC,GAA2C,CAAlD;IAAsD;EA7ChF;IAAA;IAAA,KA8CI,eAAqB;MACjB,OAAO,KAAK,OAAL,CAAa,MAAb,CAAoB,UAAC,UAAD,EAAa,KAAb;QAAA,OAAuB,UAAU,GAAG,KAAK,CAAC,UAA1C;MAAA,CAApB,EAA0E,CAA1E,CAAP;IACH;EAhDL;IAAA;IAAA,KAiDI,eAAoB;MAChB,IAAI,SAAS,GAAG,KAAK,UAArB;;MACA,IAAI,SAAS,GAAG,CAAhB,EAAmB;QACf,KAAK,UAAL,GAAkB,SAAS,GAAG,KAAK,OAAL,CAAa,MAAb,CAAoB,UAAC,CAAD;UAAA,IAAM,SAAN,QAAM,SAAN;UAAA,OAAsB,CAAC,GAAG,SAA1B;QAAA,CAApB,EAAyD,CAAzD,CAA9B;MACH;;MACD,OAAO,SAAP;IACH;EAvDL;IAAA;IAAA,KA0DI,eAAkB;MACd,IAAI,QAAQ,CAAC,YAAT,CAAsB,KAAK,KAA3B,CAAJ,EAAuC;QACnC,IAAI,CAAC,KAAK,QAAV,EAAoB;UAChB,IAAM,QAAM,GAAU,KAAK,OAA3B;UACA,KAAK,QAAL,GAAiB,QAAM,CAAC,MAAP,KAAkB,CAAlB,GACX,QAAM,CAAC,CAAD,CAAN,CAAU,OADC,GAEX,OAAO,CAAC,MAAR,OAAA,OAAO,qBAAW,QAAM,CAAC,GAAP,CAAW,UAAC,CAAD;YAAA,OAAO,CAAC,CAAC,OAAT;UAAA,CAAX,CAAX,EAFb;QAGH;;QACD,OAAO,KAAK,QAAZ;MACH;;MACD,OAAO,IAAP;IACH;EArEL;IAAA;IAAA,KAsEI,eAAqB;MACjB,IAAI,QAAQ,CAAC,YAAT,CAAsB,KAAK,KAA3B,CAAJ,EAAuC;QACnC,OAAO,KAAK,OAAL,CAAa,KAAK,OAAL,CAAa,MAAb,GAAsB,CAAnC,EAAsC,IAAtC,CAA2C,UAAlD;MACH;;MACD,OAAO,IAAP;IACH;EA3EL;IAAA;IAAA,+CA6EW;MAAA;;MAAA;QAAA;UAAA;YAAA;cAAA,uCACiB,KAAK,OADtB;cAAA;;cAAA;;YAAA;cAAA;gBAAA;gBAAA;cAAA;;cACQ,KADR;cAEC,8BAAO,KAAP;;YAFD;cAAA;cAAA;;YAAA;cAAA;cAAA;;YAAA;cAAA;cAAA;;cAAA;;YAAA;cAAA;;cAAA;;cAAA;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CA7EX;EAAA;IAAA;IAAA,OAmFW,iBAA2B;MAAA,IAArB,MAAqB,uEAAZ,KAAK,OAAO;MAC9B,OAAO,IAAI,OAAJ,CAAY,KAAK,KAAjB,EAAwB,MAAxB,CAAP;IACH;EArFL;IAAA;IAAA,OAuFW,kBAA6B;MAAA,kCAAnB,MAAmB;QAAnB,MAAmB;MAAA;;MAChC,OAAO,KAAK,KAAL,CAAW,OAAO,CAAC,OAAR,OAAA,OAAO,GAAS,IAAT,SAAkB,MAAlB,EAAlB,CAAP;IACH;EAzFL;IAAA;IAAA,OA2FW,eAAM,KAAN,EAAsB,GAAtB,EAAkC;MACrC,OAAO,UAAU,CAAC,IAAD,EAAO,KAAP,EAAc,GAAd,EAAmB,KAAK,cAAxB,CAAjB;IACH;EA7FL;IAAA;IAAA,OA+FW,oBAAqC,KAArC,EAAkD;MAErD,IAAI,KAAK,GAAG,CAAR,IAAa,KAAK,IAAI,KAAK,YAA/B,EAA6C;QAAE,OAAO,IAAP;MAAc;;MAE7D,IAAI,OAAO,GAAG,KAAK,SAAL,KAAmB,KAAK,SAAL,GAAiB,EAApC,CAAd;MACA,IAAI,KAAJ,EAAuB,KAAvB,EAAwC,MAAxC;;MAEA,IAAI,KAAK,GAAG,OAAO,CAAC,KAAD,CAAnB,EAA4B;QAAE,OAAO,KAAP;MAAe;;MAC7C,IAAI,KAAK,GAAI,CAAC,KAAK,KAAL,CAAW,QAAX,IAAuB,EAAxB,EAA4B,KAA5B,CAAb,EAA8D;QAC1D,MAAM,GAAG,KAAK,OAAL,CACJ,GADI,CACA,UAAC,MAAD;UAAA,OAAY,MAAM,CAAC,UAAP,CAAqB,KAArB,CAAZ;QAAA,CADA,EAEJ,MAFI,CAEG,UAAC,GAAD;UAAA,OAA2B,GAAG,IAAI,IAAlC;QAAA,CAFH,CAAT;;QAGA,IAAI,MAAM,CAAC,MAAP,GAAgB,CAApB,EAAuB;UACnB,OAAQ,OAAO,CAAC,KAAD,CAAP,GAAiB,IAAI,OAAJ,CAAe,KAAK,CAAC,IAArB,EAA2B,MAA3B,CAAzB;QACH;MACJ;;MAED,OAAO,IAAP;IACH;EAjHL;IAAA;IAAA,OAqHW,gBAAiD,KAAjD,EAAgE,IAAhE,EAAwE;MAC3E,IAAI,GAAG,GAAG,KAAV,CAD2E,CAE3E;;MACA,IAAI,OAAO,GAAG,KAAK,aAAnB;MAAA,IAAkC,GAAG,GAAG,OAAO,CAAC,MAAR,GAAiB,CAAzD,CAH2E,CAI3E;;MACA,IAAI,GAAG,GAAG,CAAV,EAAyB;QAAE,OAAO,IAAP;MAAc;;MACzC,IAAI,GAAG,IAAI,OAAO,CAAC,GAAD,CAAlB,EAAyB;QAAE,OAAO,IAAP;MAAc;;MACzC,IAAI,GAAG,IAAI,CAAX,EAAyB;QAAE,OAAO,IAAI,GAAG,IAAI,CAAC,IAAD,EAAO,CAAP,EAAU,GAAV,CAAP,GAAwB,CAAC,CAAD,EAAI,GAAJ,CAAnC;MAA8C;;MACzE,IAAI,GAAG,GAAG,CAAV;MAAA,IAAa,GAAG,GAAG,CAAnB;MAAA,IAAsB,GAAG,GAAG,CAA5B;;MACA,GAAG;QACC,IAAI,GAAG,GAAG,CAAN,KAAY,GAAhB,EAAqB;UACjB,OAAO,IAAI,GAAG,IAAI,CAAC,IAAD,EAAO,GAAP,EAAY,GAAG,GAAG,GAAlB,CAAP,GAAgC,CAAC,GAAD,EAAM,GAAG,GAAG,GAAZ,CAA3C;QACH;;QACD,GAAG,GAAG,GAAG,GAAI,CAAC,GAAG,GAAG,GAAP,IAAc,CAArB,GAA0B,CAAhC;QACA,GAAG,IAAI,OAAO,CAAC,GAAD,CAAd,GAAuB,GAAG,GAAG,GAA7B,GAAqC,GAAG,GAAG,GAA3C;MACH,CAND,QAMS,GAAG,GAAG,OAAO,CAAC,GAAD,CAAb,IAAsB,GAAG,KAAK,GAAG,GAAG,OAAO,CAAC,GAAD,CAAlB,CANlC;;MAOA,OAAO,IAAP;IACH;EAtIL;IAAA;IAAA,OAwIW,iBAAQ,KAAR,EAAqB;MACxB,OAAO,CAAC,CAAC,KAAK,MAAL,CAAY,KAAZ,EAAmB,KAAK,eAAxB,CAAT;IACH;EA1IL;IAAA;IAAA,OA4IW,aAAI,KAAJ,EAAiB;MACpB,OAAO,KAAK,MAAL,CAAY,KAAZ,EAAmB,KAAK,WAAxB,CAAP;IACH;EA9IL;IAAA;IAAA,OAgJW,aAAI,KAAJ,EAAmB,KAAnB,EAA4C;MAC/C,KAAK,MAAL,CAAY,KAAZ,EAAmB,iBAAa,CAAb,EAAgB,CAAhB;QAAA,IAAG,MAAH,SAAG,MAAH;QAAA,OAAsB,MAAM,CAAC,CAAD,CAAN,CAAU,GAAV,CAAc,CAAd,EAAiB,KAAjB,CAAtB;MAAA,CAAnB;IACH;EAlJL;IAAA;IAAA,OAoJW,iBAAQ,OAAR,EAA8B,MAA9B,EAA6C;MAAA;;MAChD,IAAI,MAAM,IAAI,OAAO,MAAP,KAAkB,QAAhC,EAA0C;QACtC,OAAO,KAAK,MAAL,CAAY,MAAZ,EAAoB,UAAC,IAAD,EAAO,CAAP,EAAU,CAAV;UAAA,OAAgB,MAAI,CAAC,eAAL,CAAqB,IAArB,EAA2B,CAA3B,EAA8B,CAA9B,EAAiC,OAAjC,CAAhB;QAAA,CAApB,CAAP;MACH;;MACD,OAAO,KAAK,eAAL,CAAqB,IAArB,EAA2B,CAA3B,EAA8B,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,MAAM,IAAI,CAAtB,CAA9B,EAAwD,OAAxD,CAAP;IACH;EAzJL;IAAA;IAAA,OA2JW,mBAAO;MACV,IAAQ,MAAR,GAAmB,IAAnB,CAAQ,MAAR;MACA,IAAM,CAAC,GAAG,MAAM,CAAC,MAAjB;MACA,IAAI,SAAS,GAAQ,KAAK,KAAL,CAAW,SAAhC;;MACA,IAAI,CAAC,IAAI,CAAT,EAAY;QAAE,OAAO,IAAI,SAAJ,CAAc,CAAd,CAAP;MAA0B;;MACxC,IAAI,CAAC,IAAI,CAAT,EAAY;QAAE,OAAO,MAAM,CAAC,CAAD,CAAN,CAAU,OAAV,EAAP;MAA6B;;MAC3C,IAAI,GAAG,GAAG,CAAV;MAAA,IAAa,GAAG,GAAG,IAAI,KAAJ,CAAU,CAAV,CAAnB;;MACA,KAAK,IAAI,CAAC,GAAG,CAAC,CAAd,EAAiB,EAAE,CAAF,GAAM,CAAvB,GAA2B;QACvB,GAAG,IAAI,CAAC,GAAG,CAAC,CAAD,CAAH,GAAS,MAAM,CAAC,CAAD,CAAN,CAAU,OAAV,EAAV,EAA+B,MAAtC;MACH;;MACD,IAAI,SAAS,KAAK,GAAG,CAAC,CAAD,CAAH,CAAO,WAAzB,EAAsC;QAClC,SAAS,GAAG,GAAG,CAAC,CAAD,CAAH,CAAO,WAAnB;MACH;;MACD,IAAI,GAAG,GAAG,IAAI,SAAJ,CAAc,GAAd,CAAV;MACA,IAAI,GAAG,GAAQ,SAAS,KAAK,KAAd,GAAsB,QAAtB,GAAiC,QAAhD;;MACA,KAAK,IAAI,EAAC,GAAG,CAAC,CAAT,EAAY,GAAG,GAAG,CAAvB,EAA0B,EAAE,EAAF,GAAM,CAAhC,GAAoC;QAChC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,EAAD,CAAJ,EAAS,GAAT,EAAc,GAAd,CAAT;MACH;;MACD,OAAO,GAAP;IACH;EA9KL;IAAA;IAAA,OAgLc,4BAAqC,CAArC,EAAgD,CAAhD,EAAyD;MAAA,IAA3C,OAA2C,SAA3C,OAA2C;MAAI,OAAO,OAAO,CAAC,CAAD,CAAP,CAAW,GAAX,CAAe,CAAf,CAAP;IAA2B;EAhLtG;IAAA;IAAA,OAiLc,gCAAyC,CAAzC,EAAoD,CAApD,EAA6D;MAAA,IAA3C,OAA2C,SAA3C,OAA2C;MAAI,OAAO,OAAO,CAAC,CAAD,CAAP,CAAW,OAAX,CAAmB,CAAnB,CAAP;IAA+B;EAjL9G;IAAA;IAAA,OAkLc,gCAAyC,UAAzC,EAA6D,SAA7D,EAAgF,OAAhF,EAAoG;MAAA,IAAlF,OAAkF,SAAlF,OAAkF;MAC1G,IAAI,CAAC,GAAG,UAAU,GAAG,CAArB;MAAA,IAAwB,CAAC,GAAG,OAAO,CAAC,MAApC;MACA,IAAI,KAAK,GAAG,SAAZ;MAAA,IAAuB,MAAM,GAAG,CAAhC;MAAA,IAAmC,KAAK,GAAG,CAAC,CAA5C;;MACA,OAAO,EAAE,CAAF,GAAM,CAAb,EAAgB;QACZ,IAAI,EAAE,KAAK,GAAG,OAAO,CAAC,CAAD,CAAP,CAAW,OAAX,CAAmB,OAAnB,EAA4B,KAA5B,CAAV,CAAJ,EAAmD;UAC/C,OAAO,MAAM,GAAG,KAAhB;QACH;;QACD,KAAK,GAAG,CAAR;QACA,MAAM,IAAI,OAAO,CAAC,CAAD,CAAP,CAAW,MAArB;MACH;;MACD,OAAO,CAAC,CAAR;IACH;EA7LL;IAAA;IAAA,OA+Lc,wBAAe,IAAf,EAAiC,KAAjC,EAAgD,GAAhD,EAA2D;MACjE,IAAM,MAAM,GAAgB,EAA5B;MACA,IAAQ,MAAR,GAAgD,IAAhD,CAAQ,MAAR;MAAA,IAA+B,YAA/B,GAAgD,IAAhD,CAAgB,aAAhB;;MACA,KAAK,IAAI,CAAC,GAAG,CAAC,CAAT,EAAY,CAAC,GAAG,MAAM,CAAC,MAA5B,EAAoC,EAAE,CAAF,GAAM,CAA1C,GAA8C;QAC1C,IAAM,KAAK,GAAG,MAAM,CAAC,CAAD,CAApB;QACA,IAAM,WAAW,GAAG,KAAK,CAAC,MAA1B;QACA,IAAM,WAAW,GAAG,YAAY,CAAC,CAAD,CAAhC,CAH0C,CAI1C;;QACA,IAAI,WAAW,IAAI,GAAnB,EAAwB;UAAE;QAAQ,CALQ,CAM1C;;;QACA,IAAI,KAAK,IAAI,WAAW,GAAG,WAA3B,EAAwC;UAAE;QAAW,CAPX,CAQ1C;;;QACA,IAAI,WAAW,IAAI,KAAf,IAAyB,WAAW,GAAG,WAAf,IAA+B,GAA3D,EAAgE;UAC5D,MAAM,CAAC,IAAP,CAAY,KAAZ;UACA;QACH,CAZyC,CAa1C;;;QACA,IAAM,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,KAAK,GAAG,WAApB,CAAb;QACA,IAAM,EAAE,GAAG,IAAI,CAAC,GAAL,CAAS,GAAG,GAAG,WAAf,EAA4B,WAA5B,CAAX;QACA,MAAM,CAAC,IAAP,CAAY,KAAK,CAAC,KAAN,CAAY,IAAZ,EAAkB,EAAlB,CAAZ;MACH;;MACD,OAAO,IAAI,CAAC,KAAL,CAAW,MAAX,CAAP;IACH;EArNL;IAAA;IAAA,OAOW,mBAA0E;MAAA,mCAApC,OAAoC;QAApC,OAAoC;MAAA;;MAC7E,OAAO,eAAe,CAAY,MAAZ,EAAoB,OAApB,CAAtB;IACH;IAED;;EAXJ;IAAA;IAAA,OAYW,kBAAyE;MAC5E,IAAM,MAAM,GAAG,OAAO,CAAC,OAAR,OAAA,OAAO,YAAtB;MACA,OAAO,IAAI,OAAJ,CAAe,MAAM,CAAC,CAAD,CAAN,CAAU,IAAzB,EAA+B,MAA/B,CAAP;IACH;EAfL;;EAAA;AAAA,EACY,cADZ,EA6Ea,MAAM,CAAC,QA7EpB;AAwNA;;AACA,SAAS,gBAAT,CAA8C,OAA9C,EAAkE;EAC9D,IAAI,OAAO,GAAG,IAAI,WAAJ,CAAgB,CAAC,OAAO,IAAI,EAAZ,EAAgB,MAAhB,GAAyB,CAAzC,CAAd;EACA,IAAI,MAAM,GAAG,OAAO,CAAC,CAAD,CAAP,GAAa,CAA1B;EAAA,IAA6B,MAAM,GAAG,OAAO,CAAC,MAA9C;;EACA,KAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,EAAE,KAAF,GAAU,MAA9B,GAAuC;IACnC,OAAO,CAAC,KAAD,CAAP,GAAkB,MAAM,IAAI,OAAO,CAAC,KAAK,GAAG,CAAT,CAAP,CAAmB,MAA/C;EACH;;EACD,OAAO,OAAP;AACH;AAED;;;AACA,IAAM,QAAQ,GAAG,SAAX,QAAW,CAAC,GAAD,EAAkB,GAAlB,EAAmC,MAAnC,EAAqD;EAClE,GAAG,CAAC,GAAJ,CAAQ,GAAR,EAAa,MAAb;EACA,OAAQ,MAAM,GAAG,GAAG,CAAC,MAArB;AACH,CAHD;AAKA;;;AACA,IAAM,QAAQ,GAAG,SAAX,QAAW,CAAC,GAAD,EAAa,GAAb,EAAyB,MAAzB,EAA2C;EACxD,IAAI,GAAG,GAAG,MAAV;;EACA,KAAK,IAAI,CAAC,GAAG,CAAC,CAAT,EAAY,CAAC,GAAG,GAAG,CAAC,MAAzB,EAAiC,EAAE,CAAF,GAAM,CAAvC,GAA2C;IACvC,GAAG,CAAC,GAAG,EAAJ,CAAH,GAAa,GAAG,CAAC,CAAD,CAAhB;EACH;;EACD,OAAO,GAAP;AACH,CAND","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from '../data';\nimport { Field } from '../schema';\nimport { clampRange } from '../util/vector';\nimport { DataType, Dictionary } from '../type';\nimport { selectChunkArgs } from '../util/args';\nimport { DictionaryVector } from './dictionary';\nimport { AbstractVector, Vector } from '../vector';\nimport { Clonable, Sliceable, Applicative } from '../vector';\n\n/** @ignore */\ntype ChunkedDict<T extends DataType> = T extends Dictionary ? Vector<T['dictionary']> : null | never;\n/** @ignore */\ntype ChunkedKeys<T extends DataType> = T extends Dictionary ? Vector<T['indices']> | Chunked<T['indices']> : null | never;\n\n/** @ignore */\nexport type SearchContinuation<T extends Chunked> = (column: T, chunkIndex: number, valueIndex: number) => any;\n\n/** @ignore */\nexport class Chunked<T extends DataType = any>\n    extends AbstractVector<T>\n    implements Clonable<Chunked<T>>,\n               Sliceable<Chunked<T>>,\n               Applicative<T, Chunked<T>> {\n\n    /** @nocollapse */\n    public static flatten<T extends DataType>(...vectors: (Vector<T> | Vector<T>[])[]) {\n        return selectChunkArgs<Vector<T>>(Vector, vectors);\n    }\n\n    /** @nocollapse */\n    public static concat<T extends DataType>(...vectors: (Vector<T> | Vector<T>[])[]) {\n        const chunks = Chunked.flatten<T>(...vectors);\n        return new Chunked<T>(chunks[0].type, chunks);\n    }\n\n    protected _type: T;\n    protected _length: number;\n    protected _chunks: Vector<T>[];\n    protected _numChildren: number;\n    protected _children?: Chunked[];\n    protected _nullCount: number = -1;\n    protected _chunkOffsets: Uint32Array;\n\n    constructor(type: T, chunks: Vector<T>[] = [], offsets = calculateOffsets(chunks)) {\n        super();\n        this._type = type;\n        this._chunks = chunks;\n        this._chunkOffsets = offsets;\n        this._length = offsets[offsets.length - 1];\n        this._numChildren = (this._type.children || []).length;\n    }\n\n    public get type() { return this._type; }\n    public get length() { return this._length; }\n    public get chunks() { return this._chunks; }\n    public get typeId(): T['TType'] { return this._type.typeId; }\n    public get VectorName() { return `Chunked<${this._type}>`; }\n    public get data(): Data<T> {\n        return this._chunks[0] ? this._chunks[0].data : <any> null;\n    }\n\n    public get ArrayType() { return this._type.ArrayType; }\n    public get numChildren() { return this._numChildren; }\n    public get stride() { return this._chunks[0] ? this._chunks[0].stride : 1; }\n    public get byteLength(): number {\n        return this._chunks.reduce((byteLength, chunk) => byteLength + chunk.byteLength, 0);\n    }\n    public get nullCount() {\n        let nullCount = this._nullCount;\n        if (nullCount < 0) {\n            this._nullCount = nullCount = this._chunks.reduce((x, { nullCount }) => x + nullCount, 0);\n        }\n        return nullCount;\n    }\n\n    protected _indices?: ChunkedKeys<T>;\n    public get indices(): ChunkedKeys<T> | null {\n        if (DataType.isDictionary(this._type)) {\n            if (!this._indices) {\n                const chunks = (<any> this._chunks) as DictionaryVector<T, any>[];\n                this._indices = (chunks.length === 1\n                    ? chunks[0].indices\n                    : Chunked.concat(...chunks.map((x) => x.indices))) as ChunkedKeys<T>;\n            }\n            return this._indices;\n        }\n        return null;\n    }\n    public get dictionary(): ChunkedDict<T> | null {\n        if (DataType.isDictionary(this._type)) {\n            return this._chunks[this._chunks.length - 1].data.dictionary as ChunkedDict<T>;\n        }\n        return null;\n    }\n\n    public *[Symbol.iterator](): IterableIterator<T['TValue'] | null> {\n        for (const chunk of this._chunks) {\n            yield* chunk;\n        }\n    }\n\n    public clone(chunks = this._chunks): Chunked<T> {\n        return new Chunked(this._type, chunks);\n    }\n\n    public concat(...others: Vector<T>[]): Chunked<T> {\n        return this.clone(Chunked.flatten(this, ...others));\n    }\n\n    public slice(begin?: number, end?: number): Chunked<T> {\n        return clampRange(this, begin, end, this._sliceInternal);\n    }\n\n    public getChildAt<R extends DataType = any>(index: number): Chunked<R> | null {\n\n        if (index < 0 || index >= this._numChildren) { return null; }\n\n        let columns = this._children || (this._children = []);\n        let child: Chunked<R>, field: Field<R>, chunks: Vector<R>[];\n\n        if (child = columns[index]) { return child; }\n        if (field = ((this._type.children || [])[index] as Field<R>)) {\n            chunks = this._chunks\n                .map((vector) => vector.getChildAt<R>(index))\n                .filter((vec): vec is Vector<R> => vec != null);\n            if (chunks.length > 0) {\n                return (columns[index] = new Chunked<R>(field.type, chunks));\n            }\n        }\n\n        return null;\n    }\n\n    public search(index: number): [number, number] | null;\n    public search<N extends SearchContinuation<Chunked<T>>>(index: number, then?: N): ReturnType<N>;\n    public search<N extends SearchContinuation<Chunked<T>>>(index: number, then?: N) {\n        let idx = index;\n        // binary search to find the child vector and value indices\n        let offsets = this._chunkOffsets, rhs = offsets.length - 1;\n        // return early if out of bounds, or if there's just one child\n        if (idx < 0            ) { return null; }\n        if (idx >= offsets[rhs]) { return null; }\n        if (rhs <= 1           ) { return then ? then(this, 0, idx) : [0, idx]; }\n        let lhs = 0, pos = 0, mid = 0;\n        do {\n            if (lhs + 1 === rhs) {\n                return then ? then(this, lhs, idx - pos) : [lhs, idx - pos];\n            }\n            mid = lhs + ((rhs - lhs) / 2) | 0;\n            idx >= offsets[mid] ? (lhs = mid) : (rhs = mid);\n        } while (idx < offsets[rhs] && idx >= (pos = offsets[lhs]));\n        return null;\n    }\n\n    public isValid(index: number): boolean {\n        return !!this.search(index, this.isValidInternal);\n    }\n\n    public get(index: number): T['TValue'] | null {\n        return this.search(index, this.getInternal);\n    }\n\n    public set(index: number, value: T['TValue'] | null): void {\n        this.search(index, ({ chunks }, i, j) => chunks[i].set(j, value));\n    }\n\n    public indexOf(element: T['TValue'], offset?: number): number {\n        if (offset && typeof offset === 'number') {\n            return this.search(offset, (self, i, j) => this.indexOfInternal(self, i, j, element))!;\n        }\n        return this.indexOfInternal(this, 0, Math.max(0, offset || 0), element);\n    }\n\n    public toArray(): T['TArray'] {\n        const { chunks } = this;\n        const n = chunks.length;\n        let ArrayType: any = this._type.ArrayType;\n        if (n <= 0) { return new ArrayType(0); }\n        if (n <= 1) { return chunks[0].toArray(); }\n        let len = 0, src = new Array(n);\n        for (let i = -1; ++i < n;) {\n            len += (src[i] = chunks[i].toArray()).length;\n        }\n        if (ArrayType !== src[0].constructor) {\n            ArrayType = src[0].constructor;\n        }\n        let dst = new ArrayType(len);\n        let set: any = ArrayType === Array ? arraySet : typedSet;\n        for (let i = -1, idx = 0; ++i < n;) {\n            idx = set(src[i], dst, idx);\n        }\n        return dst;\n    }\n\n    protected getInternal({ _chunks }: Chunked<T>, i: number, j: number) { return _chunks[i].get(j); }\n    protected isValidInternal({ _chunks }: Chunked<T>, i: number, j: number) { return _chunks[i].isValid(j); }\n    protected indexOfInternal({ _chunks }: Chunked<T>, chunkIndex: number, fromIndex: number, element: T['TValue']) {\n        let i = chunkIndex - 1, n = _chunks.length;\n        let start = fromIndex, offset = 0, found = -1;\n        while (++i < n) {\n            if (~(found = _chunks[i].indexOf(element, start))) {\n                return offset + found;\n            }\n            start = 0;\n            offset += _chunks[i].length;\n        }\n        return -1;\n    }\n\n    protected _sliceInternal(self: Chunked<T>, begin: number, end: number) {\n        const slices: Vector<T>[] = [];\n        const { chunks, _chunkOffsets: chunkOffsets } = self;\n        for (let i = -1, n = chunks.length; ++i < n;) {\n            const chunk = chunks[i];\n            const chunkLength = chunk.length;\n            const chunkOffset = chunkOffsets[i];\n            // If the child is to the right of the slice boundary, we can stop\n            if (chunkOffset >= end) { break; }\n            // If the child is to the left of of the slice boundary, exclude\n            if (begin >= chunkOffset + chunkLength) { continue; }\n            // If the child is between both left and right boundaries, include w/o slicing\n            if (chunkOffset >= begin && (chunkOffset + chunkLength) <= end) {\n                slices.push(chunk);\n                continue;\n            }\n            // If the child overlaps one of the slice boundaries, include that slice\n            const from = Math.max(0, begin - chunkOffset);\n            const to = Math.min(end - chunkOffset, chunkLength);\n            slices.push(chunk.slice(from, to) as Vector<T>);\n        }\n        return self.clone(slices);\n    }\n}\n\n/** @ignore */\nfunction calculateOffsets<T extends DataType>(vectors: Vector<T>[]) {\n    let offsets = new Uint32Array((vectors || []).length + 1);\n    let offset = offsets[0] = 0, length = offsets.length;\n    for (let index = 0; ++index < length;) {\n        offsets[index] = (offset += vectors[index - 1].length);\n    }\n    return offsets;\n}\n\n/** @ignore */\nconst typedSet = (src: TypedArray, dst: TypedArray, offset: number) => {\n    dst.set(src, offset);\n    return (offset + src.length);\n};\n\n/** @ignore */\nconst arraySet = (src: any[], dst: any[], offset: number) => {\n    let idx = offset;\n    for (let i = -1, n = src.length; ++i < n;) {\n        dst[idx++] = src[i];\n    }\n    return idx;\n};\n\n/** @ignore */\ninterface TypedArray extends ArrayBufferView {\n    readonly length: number;\n    readonly [n: number]: number;\n    set(array: ArrayLike<number>, offset?: number): void;\n}\n"]},"metadata":{},"sourceType":"module"}